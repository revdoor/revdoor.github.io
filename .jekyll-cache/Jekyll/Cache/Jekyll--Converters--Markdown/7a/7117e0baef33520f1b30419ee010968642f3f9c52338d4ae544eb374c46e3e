I"<h2 id="개요">개요</h2>

<p>최근에 약 1년만에 <a href="https://codeforces.com/profile/revdoor">코드포스</a>를 해보고 있습니다.</p>

<p>라운드 840이 세 번째였고, 그 이전에 두 번 더 했는데 해당 두 번은 대차게 망했었습니다. (각각 -94와 -46)</p>

<p>라운드 840은 3솔을 해서 +197을 받았습니다.</p>

<p>코드포스 성과도 정리해두려고 합니다.</p>

<h2 id="결과">결과</h2>

<p>A번: 걸린시간 00:06, 점수 488</p>

<p>B번: 걸린시간 00:24, 점수 904</p>

<p>C번: 걸린시간 00:58, 점수 1052 (WA 2번)</p>

<p>D번: 해결 실패, WA 3번</p>

<p>E번, F번: 문제 접근 못 함</p>

<p>최종: 2444점</p>

<p> </p>

<p>C번을 꽤 괜찮은 시간에 해결했다고 생각합니다. (해결한 시점 기준 정답자가 200명도 안 되었던거로 기억하네요)</p>

<p>D번을 풀었다고 생각했는데 풀지 못했던 것이 조금 아쉽네요.</p>

<h2 id="문제-설명-및-풀이">문제 설명 및 풀이</h2>

<h4 id="a번">A번</h4>

<p>수열이 주어집니다.</p>

<p>$i, j, b$를 선택해, $i$번째 수와 $j$번째 수의 $b$번째 비트를 교환할 수 있습니다.</p>

<p>이 동작을 원하는 만큼 할 수 있을 때, 수열의 최댓값과 최솟값의 차이를 최대화하는 문제입니다.</p>

<details>
<summary>풀이</summary>
<div>

    <p>모든 수에 대해서 특정 위치 비트를 전부 확인합니다. 만일 0만 있거나 1만 있을 경우 최댓값과 최솟값에서도 0 또는 1로 나타납니다.</p>

    <p>0과 1이 모두 등장하면 최댓값에서는 1, 최솟값에서는 0으로 만들어줄 수 있습니다.</p>

    <p> </p>

    <p>들어오는 수의 최댓값이 1024이므로, 최댓값 최솟값 각각에 대해 10개의 비트를 준비합니다.</p>

    <p>최댓값의 비트는 전부 0으로, 최솟값의 비트는 전부 1로 초기화해둡니다.</p>

    <p>이제 배열의 각각의 비트에 대해서, 그 비트가 1이면 같은 위치의 최댓값의 비트를 1로, 0이면 같은 위치의 최솟값의 비트를 0으로 바꿔줍니다.</p>

    <p>두 수의 차이를 계산하여 출력하면 됩니다.</p>
  </div>
</details>

<h4 id="b번">B번</h4>

<p>몬스터 여러 마리가 주어집니다. 각각의 몬스터는 체력과 파워를 가집니다.</p>

<p>Genos는 매번 모든 몬스터에게 같은 수치의 공격을 가합니다.</p>

<p>한 번 Genos의 공격이 있은 이후, 몬스터들도 Genos에게 공격을 가해 Genos의 공격 데미지를 살아 있는 몬스터들의 파워 중 최솟값만큼 줄입니다.</p>

<p>Genos가 모든 몬스터를 죽일 수 있는지 확인하는 문제입니다.</p>

<details>
<summary>풀이</summary>
<div>

    <p>지금까지 Genos가 가한 공격 총합보다 체력이 작거나 같은 몬스터는 전부 죽습니다.</p>

    <p>이분 탐색을 이용하여 빠르게 이를 확인하고 Genos의 공격 데미지를 업데이트합니다.</p>

    <p>아직 살아있는 몬스터가 남았고 Genos의 공격 데미지가 0보다 작거나 같아지면 모든 몬스터를 죽일 수 없습니다.</p>

    <p> </p>

    <p>[몬스터의 체력, 몬스터의 파워] 리스트를 체력 순으로 내림차순 정렬합니다.</p>

    <p>그 후, 몬스터의 파워를 지금까지 나온 파워 중 최솟값으로 업데이트해줍니다. (최솟값을 변수에 저장해두고 매번 업데이트하면서 사용하면 됩니다)</p>

    <p>이후 Genos가 지금까지 가한 공격 데미지를 이분 탐색으로 찾습니다.</p>

    <p>$lo$번째 몬스터까지 살았다고 했을 때, $lo$번째 몬스터의 (업데이트 해둔) 파워만큼 공격 데미지를 줄입니다.</p>

    <p>이 과정을 공격 데미지가 0보다 작거나 같아질때까지, 또는 모든 몬스터가 죽을 때까지 반복합니다.</p>

    <p>이분 탐색을 할 때, 매번 전 구간에 대해 탐색할 필요 없이 직전 탐색 후 살아있는 몬스터 구간에 대해서만 반복하면 됩니다.</p>
  </div>
</details>

<h4 id="c번">C번</h4>

<p>수열이 주어집니다. (초기 수열의 모든 수의 값은 1보다 큽니다)</p>

<p>$i, j$를 선택해, $a_i ~ a_j$까지의 모든 값을 $|a_i-a_j|$로 업데이트합니다.</p>

<p>이 과정을 원하는 만큼 반복할 수 있을 때, 수열의 합을 최대화하고 그 합을 출력하는 문제입니다.</p>

<details>
<summary>풀이</summary>
<div>

    <p>같은 구간을 두 번 선택할 경우 해당 구간의 모든 값을 0으로 만들 수 있습니다.</p>

    <p>또한, 구간의 한쪽 끝이 0일 경우 해당 구간의 모든 값을 다른쪽 끝으로 만들 수 있습니다.</p>

    <p>배열의 모든 값이 0 이상이기 때문에, 어떻게 하든 최댓값보다 큰 값은 등장할 수 없습니다.</p>

    <p>따라서, 수열의 최댓값을 가지고 생각해보면 됩니다.</p>

    <p> </p>

    <p>배열의 길이가 4 이상이라면, 해당 숫자보다 앞에 있는 숫자들 또는 뒤에 있는 숫자들 중 적어도 하나는 길이가 2보다 깁니다.</p>

    <p>따라서, 해당 구간을 전부 0으로 바꿔주고 다시 최댓값으로 바꿔줍니다.</p>

  </div>
</details>
:ET